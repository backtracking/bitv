<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Bitv (bitv.Bitv)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">bitv</a> &#x00BB; Bitv</nav><h1>Module <code>Bitv</code></h1><p>This module implements bit vectors, as an abstract datatype <code>t</code>. Since bit vectors are particular cases of arrays, this module provides the same operations as module <code>Array</code>. It also provides bitwise operations and conversions to/from integer types.</p><p>In the following, <code>false</code> stands for bit 0 and <code>true</code> for bit 1.</p><nav class="toc"><ul><li><a href="#creation,-access-and-assignment.">Creation, access and assignment.</a></li><li><a href="#copies-and-concatenations.">Copies and concatenations.</a></li><li><a href="#sub-vectors-and-filling.">Sub-vectors and filling.</a></li><li><a href="#iterators">Iterators</a></li><li><a href="#pop-count-and-other-iterations">Pop count and other iterations</a></li><li><a href="#bitwise-operations.">Bitwise operations.</a></li><li><a href="#test-functions">Test functions</a></li><li><a href="#conversions-to-and-from-strings">Conversions to and from strings</a></li><li><a href="#input/output-in-a-machine-independent-format">Input/output in a machine-independent format</a></li><li><a href="#conversions-to-and-from-lists-of-integers">Conversions to and from lists of integers</a></li><li><a href="#interpretation-of-bit-vectors-as-integers">Interpretation of bit vectors as integers</a><ul><li><a href="#type-int-(length-31/63-with-sign,-30/62-without)">type <code>int</code> (length 31/63 with sign, 30/62 without)</a></li><li><a href="#type-int32.t-(length-32-with-sign,-31-without)">type <code>Int32.t</code> (length 32 with sign, 31 without)</a></li><li><a href="#type-int64.t-(length-64-with-sign,-63-without)">type <code>Int64.t</code> (length 64 with sign, 63 without)</a></li><li><a href="#type-nativeint.t-(length-32/64-with-sign,-31/63-without)">type <code>Nativeint.t</code> (length 32/64 with sign, 31/63 without)</a></li></ul></li><li><a href="#only-if-you-know-what-you-are-doing...">Only if you know what you are doing...</a></li></ul></nav></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code></dt><dd><p>the type of bit vectors</p></dd></dl><section><header><h3 id="creation,-access-and-assignment."><a href="#creation,-access-and-assignment." class="anchor"></a>Creation, access and assignment.</h3></header><dl><dt class="spec value" id="val-create"><a href="#val-create" class="anchor"></a><code><span class="keyword">val</span> create : int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(Bitv.create n b)</code> creates a new bit vector of length <code>n</code>, initialized with <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-init"><a href="#val-init" class="anchor"></a><code><span class="keyword">val</span> init : int <span>&#45;&gt;</span> <span>(int <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(Bitv.init n f)</code> returns a fresh vector of length <code>n</code>, with bit number <code>i</code> initialized to the result of <code>(f i)</code>.</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">val</span> set : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dd><p><code>(Bitv.set v n b)</code> sets the <code>n</code>th bit of <code>v</code> to the value <code>b</code>.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">val</span> get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt><dd><p><code>(Bitv.get v n)</code> returns the <code>n</code>th bit of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">val</span> length : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p><code>Bitv.length</code> returns the length (number of elements) of the given vector.</p></dd></dl><dl><dt class="spec value" id="val-max_length"><a href="#val-max_length" class="anchor"></a><code><span class="keyword">val</span> max_length : int</code></dt><dd><p><code>max_length</code> is the maximum length of a bit vector (System dependent).</p></dd></dl></section><section><header><h3 id="copies-and-concatenations."><a href="#copies-and-concatenations." class="anchor"></a>Copies and concatenations.</h3></header><dl><dt class="spec value" id="val-copy"><a href="#val-copy" class="anchor"></a><code><span class="keyword">val</span> copy : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(Bitv.copy v)</code> returns a copy of <code>v</code>, that is, a fresh vector containing the same elements as <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-append"><a href="#val-append" class="anchor"></a><code><span class="keyword">val</span> append : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(Bitv.append v1 v2)</code> returns a fresh vector containing the concatenation of the vectors <code>v1</code> and <code>v2</code>.</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">val</span> concat : <span><a href="index.html#type-t">t</a> list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>Bitv.concat</code> is similar to <code>Bitv.append</code>, but catenates a list of vectors.</p></dd></dl></section><section><header><h3 id="sub-vectors-and-filling."><a href="#sub-vectors-and-filling." class="anchor"></a>Sub-vectors and filling.</h3></header><dl><dt class="spec value" id="val-sub"><a href="#val-sub" class="anchor"></a><code><span class="keyword">val</span> sub : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>(Bitv.sub v start len)</code> returns a fresh vector of length <code>len</code>, containing the bits number <code>start</code> to <code>start + len - 1</code> of vector <code>v</code>. Raise <code>Invalid_argument
    &quot;Bitv.sub&quot;</code> if <code>start</code> and <code>len</code> do not designate a valid subvector of <code>v</code>; that is, if <code>start &lt; 0</code>, or <code>len &lt; 0</code>, or <code>start
    + len &gt; Bitv.length a</code>.</p></dd></dl><dl><dt class="spec value" id="val-fill"><a href="#val-fill" class="anchor"></a><code><span class="keyword">val</span> fill : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dd><p><code>(Bitv.fill v ofs len b)</code> modifies the vector <code>v</code> in place, storing <code>b</code> in elements number <code>ofs</code> to <code>ofs + len - 1</code>. Raise <code>Invalid_argument &quot;Bitv.fill&quot;</code> if <code>ofs</code> and <code>len</code> do not designate a valid subvector of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-blit"><a href="#val-blit" class="anchor"></a><code><span class="keyword">val</span> blit : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>(Bitv.blit v1 o1 v2 o2 len)</code> copies <code>len</code> elements from vector <code>v1</code>, starting at element number <code>o1</code>, to vector <code>v2</code>, starting at element number <code>o2</code>. It does not work correctly if <code>v1</code> and <code>v2</code> are the same vector with the source and destination chunks overlapping. Raise <code>Invalid_argument &quot;Bitv.blit&quot;</code> if <code>o1</code> and <code>len</code> do not designate a valid subvector of <code>v1</code>, or if <code>o2</code> and <code>len</code> do not designate a valid subvector of <code>v2</code>.</p></dd></dl></section><section><header><h3 id="iterators"><a href="#iterators" class="anchor"></a>Iterators</h3></header><dl><dt class="spec value" id="val-iter"><a href="#val-iter" class="anchor"></a><code><span class="keyword">val</span> iter : <span>(bool <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>(Bitv.iter f v)</code> applies function <code>f</code> in turn to all the elements of <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">val</span> map : <span>(bool <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>Given a function <code>f</code>, <code>(Bitv.map f v)</code> applies <code>f</code> to all the elements of <code>v</code>, and builds a vector with the results returned by <code>f</code>.</p></dd></dl><dl><dt class="spec value" id="val-iteri"><a href="#val-iteri" class="anchor"></a><code><span class="keyword">val</span> iteri : <span>(int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-mapi"><a href="#val-mapi" class="anchor"></a><code><span class="keyword">val</span> mapi : <span>(int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> bool)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p><code>Bitv.iteri</code> and <code>Bitv.mapi</code> are similar to <code>Bitv.iter</code> and <code>Bitv.map</code> respectively, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p></dd></dl><dl><dt class="spec value" id="val-fold_left"><a href="#val-fold_left" class="anchor"></a><code><span class="keyword">val</span> fold_left : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>(Bitv.fold_left f x v)</code> computes <code>f (... (f (f x (get v 0)) (get
    v 1)) ...) (get v (n-1))</code>, where <code>n</code> is the length of the vector <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-fold_right"><a href="#val-fold_right" class="anchor"></a><code><span class="keyword">val</span> fold_right : <span>(bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dd><p><code>(Bitv.fold_right f a x)</code> computes <code>f (get v 0) (f (get v 1)
    ( ... (f (get v (n-1)) x) ...))</code>, where <code>n</code> is the length of the vector <code>v</code>.</p></dd></dl><dl><dt class="spec value" id="val-foldi_left"><a href="#val-foldi_left" class="anchor"></a><code><span class="keyword">val</span> foldi_left : <span>(<span class="type-var">'a</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt><dt class="spec value" id="val-foldi_right"><a href="#val-foldi_right" class="anchor"></a><code><span class="keyword">val</span> foldi_right : <span>(int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span>)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span class="type-var">'a</span> <span>&#45;&gt;</span> <span class="type-var">'a</span></code></dt></dl></section><section><header><h3 id="pop-count-and-other-iterations"><a href="#pop-count-and-other-iterations" class="anchor"></a>Pop count and other iterations</h3></header><dl><dt class="spec value" id="val-pop"><a href="#val-pop" class="anchor"></a><code><span class="keyword">val</span> pop : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dd><p>Population count, i.e., number of 1 bits</p></dd></dl><dl><dt class="spec value" id="val-iteri_true"><a href="#val-iteri_true" class="anchor"></a><code><span class="keyword">val</span> iteri_true : <span>(int <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dd><p><code>iteri_true f v</code> applies function <code>f</code> in turn to all indexes of the elements of <code>v</code> which are set (i.e. <code>true</code>); indexes are visited from least significant to most significant.</p></dd></dl><dl><dt class="spec value" id="val-gray_iter"><a href="#val-gray_iter" class="anchor"></a><code><span class="keyword">val</span> gray_iter : <span>(<a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit)</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> unit</code></dt><dd><p><code>gray_iter f n</code> iterates function <code>f</code> on all bit vectors of length <code>n</code>, once each, using a Gray code. The order in which bit vectors are processed is unspecified.</p></dd></dl></section><section><header><h3 id="bitwise-operations."><a href="#bitwise-operations." class="anchor"></a>Bitwise operations.</h3><p>All the bitwise operations return fresh vectors.</p></header><dl><dt class="spec value" id="val-bw_and"><a href="#val-bw_and" class="anchor"></a><code><span class="keyword">val</span> bw_and : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>bitwise AND; raises <code>Invalid_argument</code> if the two vectors do not have the same length</p></dd></dl><dl><dt class="spec value" id="val-bw_or"><a href="#val-bw_or" class="anchor"></a><code><span class="keyword">val</span> bw_or : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>bitwise OR; raises <code>Invalid_argument</code> if the two vectors do not have the same length</p></dd></dl><dl><dt class="spec value" id="val-bw_xor"><a href="#val-bw_xor" class="anchor"></a><code><span class="keyword">val</span> bw_xor : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>bitwise XOR; raises <code>Invalid_argument</code> if the two vectors do not have the same length</p></dd></dl><dl><dt class="spec value" id="val-bw_not"><a href="#val-bw_not" class="anchor"></a><code><span class="keyword">val</span> bw_not : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>bitwise NOT</p></dd></dl><dl><dt class="spec value" id="val-shiftl"><a href="#val-shiftl" class="anchor"></a><code><span class="keyword">val</span> shiftl : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>moves bits from least to most significant; introduces zeros</p></dd></dl><dl><dt class="spec value" id="val-shiftr"><a href="#val-shiftr" class="anchor"></a><code><span class="keyword">val</span> shiftr : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dd><p>moves bits from most to least significant; introduces zeros</p></dd></dl></section><section><header><h3 id="test-functions"><a href="#test-functions" class="anchor"></a>Test functions</h3></header><dl><dt class="spec value" id="val-all_zeros"><a href="#val-all_zeros" class="anchor"></a><code><span class="keyword">val</span> all_zeros : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>returns <code>true</code> if and only if the vector only contains zeros</p></dd></dl><dl><dt class="spec value" id="val-all_ones"><a href="#val-all_ones" class="anchor"></a><code><span class="keyword">val</span> all_ones : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bool</code></dt><dd><p>returns <code>true</code> if and only if the vector only contains ones</p></dd></dl></section><section><header><h3 id="conversions-to-and-from-strings"><a href="#conversions-to-and-from-strings" class="anchor"></a>Conversions to and from strings</h3></header><dl><dt class="spec module" id="module-L"><a href="#module-L" class="anchor"></a><code><span class="keyword">module</span> <a href="L/index.html">L</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>With least significant bits first.</p></dd></dl><dl><dt class="spec module" id="module-M"><a href="#module-M" class="anchor"></a><code><span class="keyword">module</span> <a href="M/index.html">M</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></dt><dd><p>With most significant bits first.</p></dd></dl></section><section><header><h3 id="input/output-in-a-machine-independent-format"><a href="#input/output-in-a-machine-independent-format" class="anchor"></a>Input/output in a machine-independent format</h3><p>The following functions export/import a bit vector to/from a channel or bytes, in a way that is compact, independent of the machine architecture, and independent of the OCaml version. For a bit vector of length <code>n</code>, the number of bytes of this external representation is 4+ceil(n/8) on a 32-bit machine and 8+ceil(n/8) on a 64-bit machine.</p></header><dl><dt class="spec value" id="val-output_bin"><a href="#val-output_bin" class="anchor"></a><code><span class="keyword">val</span> output_bin : Stdlib.out_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-input_bin"><a href="#val-input_bin" class="anchor"></a><code><span class="keyword">val</span> input_bin : Stdlib.in_channel <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_bytes"><a href="#val-to_bytes" class="anchor"></a><code><span class="keyword">val</span> to_bytes : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> bytes</code></dt><dt class="spec value" id="val-of_bytes"><a href="#val-of_bytes" class="anchor"></a><code><span class="keyword">val</span> of_bytes : bytes <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl></section><section><header><h3 id="conversions-to-and-from-lists-of-integers"><a href="#conversions-to-and-from-lists-of-integers" class="anchor"></a>Conversions to and from lists of integers</h3><p>The list gives the indices of bits which are set (ie <code>true</code>).</p></header><dl><dt class="spec value" id="val-to_list"><a href="#val-to_list" class="anchor"></a><code><span class="keyword">val</span> to_list : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> <span>int list</span></code></dt><dt class="spec value" id="val-of_list"><a href="#val-of_list" class="anchor"></a><code><span class="keyword">val</span> of_list : <span>int list</span> <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-of_list_with_length"><a href="#val-of_list_with_length" class="anchor"></a><code><span class="keyword">val</span> of_list_with_length : <span>int list</span> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt></dl></section><section><header><h3 id="interpretation-of-bit-vectors-as-integers"><a href="#interpretation-of-bit-vectors-as-integers" class="anchor"></a>Interpretation of bit vectors as integers</h3><p>Least significant bit comes first (ie is at index 0 in the bit vector). <code>to_xxx</code> functions truncate when the bit vector is too wide, and raise <code>Invalid_argument</code> when it is too short. Suffix <code>_s</code> means that sign bit is kept, and <code>_us</code> that it is discarded.</p></header><section><header><h4 id="type-int-(length-31/63-with-sign,-30/62-without)"><a href="#type-int-(length-31/63-with-sign,-30/62-without)" class="anchor"></a>type <code>int</code> (length 31/63 with sign, 30/62 without)</h4></header><dl><dt class="spec value" id="val-of_int_s"><a href="#val-of_int_s" class="anchor"></a><code><span class="keyword">val</span> of_int_s : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_int_s"><a href="#val-to_int_s" class="anchor"></a><code><span class="keyword">val</span> to_int_s : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt><dt class="spec value" id="val-of_int_us"><a href="#val-of_int_us" class="anchor"></a><code><span class="keyword">val</span> of_int_us : int <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_int_us"><a href="#val-to_int_us" class="anchor"></a><code><span class="keyword">val</span> to_int_us : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int</code></dt></dl></section><section><header><h4 id="type-int32.t-(length-32-with-sign,-31-without)"><a href="#type-int32.t-(length-32-with-sign,-31-without)" class="anchor"></a>type <code>Int32.t</code> (length 32 with sign, 31 without)</h4></header><dl><dt class="spec value" id="val-of_int32_s"><a href="#val-of_int32_s" class="anchor"></a><code><span class="keyword">val</span> of_int32_s : Stdlib.Int32.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_int32_s"><a href="#val-to_int32_s" class="anchor"></a><code><span class="keyword">val</span> to_int32_s : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Stdlib.Int32.t</code></dt><dt class="spec value" id="val-of_int32_us"><a href="#val-of_int32_us" class="anchor"></a><code><span class="keyword">val</span> of_int32_us : Stdlib.Int32.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_int32_us"><a href="#val-to_int32_us" class="anchor"></a><code><span class="keyword">val</span> to_int32_us : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Stdlib.Int32.t</code></dt></dl></section><section><header><h4 id="type-int64.t-(length-64-with-sign,-63-without)"><a href="#type-int64.t-(length-64-with-sign,-63-without)" class="anchor"></a>type <code>Int64.t</code> (length 64 with sign, 63 without)</h4></header><dl><dt class="spec value" id="val-of_int64_s"><a href="#val-of_int64_s" class="anchor"></a><code><span class="keyword">val</span> of_int64_s : Stdlib.Int64.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_int64_s"><a href="#val-to_int64_s" class="anchor"></a><code><span class="keyword">val</span> to_int64_s : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Stdlib.Int64.t</code></dt><dt class="spec value" id="val-of_int64_us"><a href="#val-of_int64_us" class="anchor"></a><code><span class="keyword">val</span> of_int64_us : Stdlib.Int64.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_int64_us"><a href="#val-to_int64_us" class="anchor"></a><code><span class="keyword">val</span> to_int64_us : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Stdlib.Int64.t</code></dt></dl></section><section><header><h4 id="type-nativeint.t-(length-32/64-with-sign,-31/63-without)"><a href="#type-nativeint.t-(length-32/64-with-sign,-31/63-without)" class="anchor"></a>type <code>Nativeint.t</code> (length 32/64 with sign, 31/63 without)</h4></header><dl><dt class="spec value" id="val-of_nativeint_s"><a href="#val-of_nativeint_s" class="anchor"></a><code><span class="keyword">val</span> of_nativeint_s : Stdlib.Nativeint.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_nativeint_s"><a href="#val-to_nativeint_s" class="anchor"></a><code><span class="keyword">val</span> to_nativeint_s : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Stdlib.Nativeint.t</code></dt><dt class="spec value" id="val-of_nativeint_us"><a href="#val-of_nativeint_us" class="anchor"></a><code><span class="keyword">val</span> of_nativeint_us : Stdlib.Nativeint.t <span>&#45;&gt;</span> <a href="index.html#type-t">t</a></code></dt><dt class="spec value" id="val-to_nativeint_us"><a href="#val-to_nativeint_us" class="anchor"></a><code><span class="keyword">val</span> to_nativeint_us : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> Stdlib.Nativeint.t</code></dt></dl></section></section><section><header><h3 id="only-if-you-know-what-you-are-doing..."><a href="#only-if-you-know-what-you-are-doing..." class="anchor"></a>Only if you know what you are doing...</h3></header><dl><dt class="spec value" id="val-unsafe_set"><a href="#val-unsafe_set" class="anchor"></a><code><span class="keyword">val</span> unsafe_set : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool <span>&#45;&gt;</span> unit</code></dt><dt class="spec value" id="val-unsafe_get"><a href="#val-unsafe_get" class="anchor"></a><code><span class="keyword">val</span> unsafe_get : <a href="index.html#type-t">t</a> <span>&#45;&gt;</span> int <span>&#45;&gt;</span> bool</code></dt></dl></section></div></body></html>